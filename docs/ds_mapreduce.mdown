# Handling multiple months for single and multi-key for single and multiple DSes

- Types of reports
	- By keys
		- Flattens dates so we only know values for the entire range (date data is lost)
	- By date/keys
		- Flattens by date/key, so we only know values for keys within each date
	- By date
		- Flattens by date, so we only know values for each date (key data is lost)

- Add all rows into EvaluationCxt
	- This will group rows based on month
	- (multi-key only) Within each month, we nest keys hierarchically by key structure
	- Since we don't report on partial keys, we don't need to store aggregates for them
	- Extracts attribute values from DSes and puts them into named fields
	- At this point, there will be duplicate keys and dates, a composite of any/all DSes
- Generate report
	- Logic
		1. Break down distributable values
			- Do this within each month, splitting up values by their dependent fields
			- Only dependent fields fields are supported at this step
		2. Roll up aggregate values
			- Do this within each month, and then collect those in parent cxts
			- Only bound fields fields are supported at this step
			- Run `Map` for all values (only values with a map defined need by run)
			- `Reduce` is used to roll up the values
		3. Pre-flatten by key (multi-key only)
			- Multiple keys let us break down distributable values, but we don't need them anymore; 
			- Only the final partial key is used, so we group on this key, and `Map/Reduce` again
		4. Run formula evaluator
			- We now effectively have "flattened" rows at the root evaluation cxt for all bound fields
				- For "by key" reports, this is a single flattened row per key representing the entire date range
				- For "by date" reports, we will have a single flattened row per date, representing all keys
			- Running formulae in dependency order will fill in the rest of the fields in this "flattened" root row
			- As necessary, the formulae can further access month totals to generate the needed values

## Map/Reduce

- Each attribute has a map and reduce step for rolling up
- In normal cases, it would just be `map = value`, `reduce = Sum(values)`
- For the `avgPos`, it would be `map = Multiply(value, impressions)`, `reduce = Divide(Sum(values), impressions)`

## Dependent fields

- Each attribute has an optional dependent field for breaking down values, `expand = ProportionallyBy(impressions)`

## Issues

Each DS contributes rows, and there is a lot of computation going on that doens't need to happen. Ideally we would `reduce` as soon as possible!